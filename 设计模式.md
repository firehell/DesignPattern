# 设计模式

## 单例模式

### 什么是单例？

一个类只允许创建一个实例，那这个类就是单例类。 **这里的唯一可以是线程，进程，和多进程**

### 单例的创建

> 1. 饿汉式
> 2. 懒汉式
> 3. 双重校验锁
> 4. 静态内部类
> 5. 枚举

**饿汉**和**懒汉**主要区别是饿汉直接创建而懒汉有一个懒加载的过程，但是如果一个对象创建非常耗费资源，可以考虑不需要懒加载，把耗费资源的这个过程提前进行，这样也符合有问题早暴露的思想。

双重校验锁的方式里面用到**防止指令重排**的思路，但在jdk高版本中基本上已经把创建对象和new变成原子化操作了

静态内部类是使用了JVM的**类加载机制**来让JVM去实现单例

枚举使用了枚举的特性来实现

### 单例的使用场景

> 1. 处理资源访问冲突，避免重复创建多个对象
> 2. 表示全局唯一的类
> 3. 对象创建很耗费资源避免创建多个对象导致OOM使用单例

#### 单例的缺点

##### 1. 单例对OOP特性不友好

首先单例类支持继承但是如果继承单例类就容易让开发者很奇怪，所以一般默认使用单例类就放弃了继承和多态这两个面向对象特性，如果后面需要打破单例，那就需要修改所有用到单例的地方。

##### 2. 单例会隐藏类之间的依赖关系

在通过构造函数和参数传递的方式我们能很方便的阅读代码，但是单例不需要传递参数也不需要显示的去创建，当代码关系很复杂的时候可读性就很低。

##### 3. 单例对可测试性不友好

##### 4. 单例不支持有参数的构造函数

单例分类

> + 线程内唯一，线程间不唯一
>
> + 进程内唯一，进程间不唯一
> + 进程间唯一

